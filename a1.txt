CREATE TABLE library.tags (
    pk integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tag text NOT NULL,
    parent integer
);

insert into tags (tag) values ('Database'),('Operating Systems');
set search_path TO library,public
alter table tags set schema library 
	
select tag from tags;
select title from categories;
select tag as datalist from tags UNION select title as datalist from categories;

select * from posts


-- cross join
select c.pk,c.title,p.pk,p.category,p.title from categories c,posts p;
--inner join
-- filter all the rows that have the same value as the category field 
--(category.pk = posts.category)
select c.pk,c.title,p.pk,p.category,p.title 
	from categories c,posts p where c.pk=p.category;
--it can be written in an other way 
select c.pk,c.title,p.pk,p.category,p.title from categories c 
inner join posts p on c.pk=p.category
--INNER JOIN versus EXISTS/In
--search for all posts that belong to the Database category using the INNER JOIN condition
select c.pk,c.title,p.pk,p.category,p.title from categories c 
inner join posts p on c.pk=p.category where c.title='Database';
 --LEFT JOINS
select c.*,p.category,p.title from categories c left join posts p on c.pk=p.category;
--This query returns all records of the categories table and 
--returns the matched records from the posts table.
--Using RIGHT JOIN
select c.*,p.category,p.title from posts p right join categories c on c.pk=p.category;
--Full outer join
-- FULL OUTER JOIN is the combination of what we would have if we put together the right 
-- join and the left join. 


create temp table new_posts as select * from posts;
select 3
select c.pk,c.title,p.pk,p.title from categories c inner join new_posts p on p.catgeory = c.pk;


--To have the left and right joins between the new_posts and category tables, 
--we’d have to use the full outer join and write the following
select c.pk,c.title,p.pk,p.title from categories c full 
outer join new_posts p on p.category=c.pk;

--Using LATERAL JOIN
--A lateral join is a type of join in SQL that allows you to join a table with a subquery,
--where the subquery is run for each row of the main table. The subquery is executed 
--before joining the rows and the result is used to join the rows. With this join mode, 
--you can use information from one table to filter or process data from another table

alter table posts add likes integer default 0;
select title,likes from posts order by likes ;

--to search for all users that have posts with likes greater than 2; 
 select u.* from users u where exists (select 1 from posts p 
where u.pk=p.author and likes > 2 ) ;

--suppose now that we want the value of the likes field too
select u.username,q.* from users u join lateral (select author, 
title,likes from posts p where u.pk=p.author and likes > 2 ) as q on true;


--UNION/UNION ALL 
--The UNION operator is used to combine the resultset of two or more SELECT statements.
--• Each SELECT statement within UNION must have the same number of columns.
--• The columns must have similar data types.
--• The columns in each SELECT statement must be in the same order.
insert into tags (tag) values ('Database'),('Operating System');
select tag from tags;
select title from categories;
select tag as datalist from tags union select title as datalist from categories;

--EXCEPT/INTERSECT 
-- The EXCEPT want to operator returns rows by comparing the resultsets of two or more queries. 
-- The EXCEPT operator returns distinct rows from the first (left) query that is not in the output of 
-- the second (right) query. Similar to the UNION operator, the EXCEPT operator can also compare 
-- queries that have the same number and the same datatype of fields

-- except common everything will be displayed
	
select title as datalist from categories except select tag as 
datalist from tags order by 1

-- intersect
select title as datalist from categories intersect select tag as 
datalist from tags order by 1

-- Using UPSERT
--An UPSERT statement is used when we want to insert a new record on top of the existing record or update an existing 
--record. To do this in PostgreSQL, we can use the ON CONFLICT keyword:


	CREATE TABLE library.posts_tags (
    tag_pk integer NOT NULL,
    post_pk integer NOT NULL
);


alter table posts_tags add constraint posts_tags_pkey primary key (tag_pk,post_pk);

insert into posts_tags (post_pk ,tag_pk) values (7,3),(5,3),(6,3);
select * from posts_tags ;
insert into posts_tags (post_pk ,tag_pk) values (5,3);
insert into posts_tags (post_pk ,tag_pk) values (5,3) ON CONFLICT DO NOTHING;

insert into posts_tags (post_pk ,tag_pk) values (2,1) ON CONFLICT DO NOTHING;


---MERGE

create temp table new_data as select * from categories limit 0;
insert into new_data (pk,title,description) values (1,'Database Discussions','Database discussions'),(2,'Unix/Linux discussion','Unix and Linux discussions');


select * from categories ;
select * from new_data;
merge into categories c
using new_data n on c.pk=n.pk
when matched then
  update set title=n.title,description=n.description
when not matched then
  insert (pk,title,description)
  OVERRIDING SYSTEM VALUE values (n.pk,n.title,n.description);
